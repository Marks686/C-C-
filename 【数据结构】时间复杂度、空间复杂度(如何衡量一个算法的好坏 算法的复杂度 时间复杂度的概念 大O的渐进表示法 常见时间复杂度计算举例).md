# 1.算法效率
 
## 1.1如何衡量一个算法的好坏
<center>站在时间的维度 叫时间复杂度
<center>站在空间的维度叫空间复杂度


## 1.2算法的复杂度
>通过这两个维度我们可以评估算法的效率，它的时间复杂度是多少，空间复杂度是多少，如何优化它？优化了以后是多少？


时间复杂度主要衡量一个算法运行的快慢，空间复杂度主要衡量一个算法运行所需要的额外空间，如今算法的时间复杂度我们需要特别关注。
# 2.时间复杂度
## 2.1时间复杂度的概念
在计算就科学中，**算法的时间复杂度是一个函数**（函数指的是数学里面的带未知数的函数表达式），定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是算不出来的，只有把程序放在机器上跑起来，才能知道。如果让每个算法都上机测试是很麻烦的，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比，**算法中的基本操作的执行次数，为算法的时间复杂度**。所以，找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。
![在这里插入图片描述](https://img-blog.csdnimg.cn/96b7a201c2fb4ce79ead4a1f1f43d611.png)
>计算Func1 中时间复杂度函数式

```c
void Func1(int N)
{
	int count = 0;
	for (int i = 0; i < N; ++i)
	{
		for (int j = 0; j < N; ++j)
		{
			++count;
		}
	}

	for (int k = 0; k < 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}
```

```c
计算次数时间复杂度函数式：N*N + 2*N + 10
```
实际上我们计算时间复杂度时，并不一定要计算精确的执行次数，而是需要**大概执行次数，那么这里我们使用大O的渐进表示法**
## 2.2大O的渐进表示法

> 大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。
推导大O阶方法：
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c4fd77205dc54638af1f0af9aa018802.png)

算的是大概的次数，表示估算不是精确的执行次数


## 2.3常见时间复杂度计算举例
![在这里插入图片描述](https://img-blog.csdnimg.cn/12f6596de9464c729054c710ec57f932.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/14d2e8fb16244823bffbfefe7c7f5b86.png)
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/d01261c824e24facb3957dbd17917127.png)
**时间复杂度不要去数循环，要看算法逻辑，进行计算时间复杂度**
![在这里插入图片描述](https://img-blog.csdnimg.cn/a9537038b94548629f01b62d7dcfb9cd.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/31cefb4d2b71442a98ed5b83304842f2.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/7b10a715870446b581b310d313838fab.png)

# 3.空间复杂度

> 空间复杂度也是一个数学表达式，是对一个算法在运行过程中**（额外）临时占用存储空间大小的量度 。**
空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。
空间复杂度计算规则基本跟实践复杂度类似，也使用**大O渐进表示**法。
注意：**函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。**

随着时代的发展，设备内存变大，空间复杂度的优化没有太大的需求了，相对而言不那么关注空间复杂度。

